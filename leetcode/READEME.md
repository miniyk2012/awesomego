## 11月9日
0005. 最长回文子串 动态规划

## 11月29日
0011. 盛最多水的容器 双指针

    总是移动数字较小的那个指针, 这是因为如过较小的柱子不动, 无论怎么移动较长的柱子, 水的面积只会更小, 因此可以排除掉这个较短的柱子, 也就是移动较短的柱子.
    非常形象化的题解(搜索空间问题): https://leetcode.cn/problems/container-with-most-water/solution/on-shuang-zhi-zhen-jie-fa-li-jie-zheng-que-xing-tu/

0016. 3Sum Closest

    左右指针夹逼法, 需要把数组排序, 固定1个值后, 剩下的2个指针从最边缘往中间移动, 如果和大于targe, 右指针往左移, 反之左指针往右移, 穷举出所有可能性中最接近target的即可. 之所以排序, 是因为2个数的和想要接近某个固定值, 对有序数组做双指针移动搜索可以O(n)穷举出所有可能的值.

0015. 3Sum

    使用map保存已出现过的数,可以时间复杂度降到O(n^2), 主要是不重复非常麻烦, 可以先排序, 保存首次出现的那个数的下标, 然后在不遗漏结果的前提下判断当前数和前一个数相同的话跳过, 细节看我solution1的解答, 但是发现排名很靠后.

    排序后, 外层循环遍历第一个数, 内存循环双指针法, 若3者和大于0, R左移, 若三者和小于0, L右移.
    去重这么做: 连续相同的数跳过即可. 
    优化: 如果第一个数>0, 则跳出外层循环. 若前2个数和大于0, 跳出内层循环.

0019. Remove Nth Node From End of List

    左指针指向头, 右指针从头开始先移动N个位置, 然后2个指针一起往右移动, 直到右指针到底, 则左指针指向要删除的节点的前一个位置. 删除该节点即可. 一次遍历就能完成. 考虑好边界情况.

    如果我们要删除节点y，我们需要知道节点y的前驱节点x，并将x的指针指向y的后继节点。但由于头节点不存在前驱节点，因此我们需要在删除头节点时进行特殊判断。但如果我们添加了哑节点，那么头节点的前驱节点就是哑节点本身，此时我们就只需要考虑通用的情况即可。

0020. 括号匹配

    golang的s[1]得到的是byte, 迭代得到的是rune. 具体可以见learning/stringstudy的代码. 'x'可以与byte或rune比较, 但rune和byte不能比较.

0071. 简化路径

    法1: 使用栈保存每层的目录, 迭代字符串的时候用状态机来省去繁琐的判断. 分为4种状态: /状态, 一个.状态, 2个.状态, 输入目录状态. 还是很清楚的.

    法2: 用内置方法strings.Split(path, "/")把每层都分开来, 用栈保存目录, 显然更简便

0026. 删除有序数组中的重复项

    简单, 保存一个不同元素要填入的下标位置即可.

0027. 移除元素

    简单, 保存将要填入的下标位置即可.

0028. 找出字符串中第一个匹配项的下标

    法1. 法2 都是2层循环暴力破解, 不过法2写的非常清爽.
    
    法3: 字符串匹配算法, 可以用KMP算法做. 难度较大, 不过很有意思: https://blog.csdn.net/v_july_v/article/details/7041827

0031. 下一个排列

    注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。我们希望找到一种方法，能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。具体地：

    我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。

    同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。

    具体地，我们这样描述该算法，对于长度为n 的排列 a:
    首先从后向前查找第一个顺序对 (i,i+1)，满足 a[i]<a[i+1]。这样「较小数」即为 a[i]。此时[i+1,n)必然是下降序列。可以证明a[i]是最靠右的较小数.
    
    如果找到了顺序对，那么在区间 [i+1,n) 中从后向前查找第一个元素 j 满足 a[i]<a[j]。这样「较大数」即为 a[j]。
    
    交换 a[i] 与 a[j]，此时可以证明区间 [i+1,n) 必为降序。我们可以直接使用双指针反转区间 [i+1,n) 使其变为升序，而无需对该区间进行排序。

0061. 旋转链表

    将链表闭合成环, 然后在指定位置断开, 新head在原链表的第n-(k mod n)个节点处(从0开始计数).

0083. 删除排序链表中的重复元素I

    重复的数保留一个

    循环结束时, 要判断最后的那个值是否和前面的值重复, 这个容易漏掉

0082. 删除排序链表中的重复元素II

    重复的数直接删除. prev指向需保留的末尾节点, 用哑元节点操作会非常方便, 无须额外判断头节点.

0086. Partition List

    法1: 提供2个slice分别存放<x和>=x的节点, 然后遍历老链表, 依次放到2个slice里, 最后构造一个新的链表, 小slice先构造, 大slice晚构造, 产生的新链表符合题意.

    法2: 无须先放到slice里, 可以在遍历老链表的时候分别构造2个链表, 一个存<x的一个存>=x的, 然后把大的链表接到小链表的后面就行.

    法3: 构造双向链表, 不过时间复杂度是O(n^2)

0002. Add Two Numbers

    如果链表遍历结束后，有 carry>0, 还需要在答案链表的后面附加一个节点，节点的值为carry.

0033. Search in Rotated Sorted Array

    因为要求log(n),因此使用二分法, 仔细思考mid和target的关系, 虽然array只是部分有序, 但仍然可以得出正确的结果.

0034. 在排序数组中查找元素的第一个和最后一个位置

   法1: 顺序查找需要O(n)复杂度, 题目要求log(n), 因此需要使用二分法.

   法2: 二分法有一个模板, 这里好好做个总结. 
   
   1. 查找第一个值等于给定值的元素
   2. 查找最后一个值等于给定值的元素
   3. 查找第一个大于等于给定值的元素
   4. 查找最后一个小于等于给定值的元素

```golang
// 二分查找第一个与 target 相等的元素，时间复杂度 O(logn)
func searchFirstEqualElement(nums []int, target int) int {
	low, high := 0, len(nums)-1
	for low <= high {
		mid := low + ((high - low) >> 1)
		if nums[mid] > target {
			high = mid - 1
		} else if nums[mid] < target {
			low = mid + 1
		} else {
			if (mid == 0) || (nums[mid-1] != target) { // 找到第一个与 target 相等的元素
				return mid
			}
			high = mid - 1
		}
	}
	return -1
}

// 二分查找最后个与 target 相等的元素，时间复杂度 O(logn)
func searchLastEqualElement(nums []int, target int) int {
	low, high := 0, len(nums)-1
	for low <= high {
		mid := low + ((high - low) >> 1)
		if nums[mid] > target {
			high = mid - 1
		} else if nums[mid] < target {
			low = mid + 1
		} else {
			if (mid == len(nums)-1) || (nums[mid+1] != target) { // 找到最后一个与 target 相等的元素
				return mid
			}
			low = mid + 1
		}
	}
	return -1
}

// 二分查找第一个大于等于 target 的元素，时间复杂度 O(logn)
func searchFirstGreaterElement(nums []int, target int) int {
	low, high := 0, len(nums)-1
	for low <= high {
		mid := low + ((high - low) >> 1)
		if nums[mid] >= target {
			if (mid == 0) || (nums[mid-1] < target) { // 找到第一个大于等于 target 的元素
				return mid
			}
			high = mid - 1
		} else {
			low = mid + 1
		}
	}
	return -1
}

// 二分查找最后一个小于等于 target 的元素，时间复杂度 O(logn)
func searchLastLessElement(nums []int, target int) int {
	low, high := 0, len(nums)-1
	for low <= high {
		mid := low + ((high - low) >> 1)
		if nums[mid] <= target {
			if (mid == len(nums)-1) || (nums[mid+1] > target) { // 找到最后一个小于等于 target 的元素
				return mid
			}
			low = mid + 1
		} else {
			high = mid - 1
		}
	}
	return -1
}
```

    法3. 用sort.SearchInts()来做, 对非递减的数组返回第一个<=target的位置, 它是对sort.Search()的封装, 无须提供比较函数, 非常方便. 见`easySearchRange`的实现.

6280. 范围内最接近的两个质数

	先用筛法找到素数, 然后遍历找出间距最小的素数. 找素数的时候, 只能从1开始去筛; 找相邻素数最小间隔的时候, 再从left开始看间隔.
	
	筛法的思想是先把[2, right]区间所有数都标记为素数, 然后i从2开始迭代到sqrt(right): 如果i是素数, 将i^2, i^2+i, i^2+2i的数置为合数. 迭代完成最后剩下的就是素数.

0075. 颜色分类(荷兰国旗问题)

	法1. 统计出数组中0,1,2的个数, 再根据它们的数量，重写整个数组.

	法2. 2次遍历, 第一次把0交换到开头, 第2次把1放到0的后面, 此时，所有的2都出现在数组的尾部，这样我们就完成了排序。

	法3. 1次遍历. 2个指针, p0指向下一个0的位置, p1指向下一个1的位置. 注意当交换0的时候, 可能会把1交换出来. 这个1要交换回1的末尾.

	注: 这种遍历并交换的方式特别像快跑, 有必要再实现一个快排, 以及合并排序.

# 2023年

0080. Remove Duplicates from Sorted Array II

	法1: 双指针, 左边的指向下一个要填充的位置, 右边的指向下一个要迭代的位置, 并且用一个repeated保存当前重复的个数.
	
	法2: 法1没有用到数组递增的特性, 由于数组是递增的, 因此无须保存当前重复个数, 只要判断right指向的数是否left-2位置的数是否相等即可

## 1月20日

0092. 翻转链表的一部分

	构造一个新的头结点指向当前的头, 然后再操作. 

	可以记录left的前一个位置和right的下一个位置, 截取出中间部分并和其他部分截断, 然后用翻转列表的函数翻转中间部分, 再重新连起来, 比较清晰, 不过需要迭代2次.

	我的做法就是每次迭代的时候做反向连接, 但不抽取出翻转整个链表的函数 只需要迭代一次. 不过逻辑略不清晰.

	法2: 头插法. 在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置. 循环不变量: cur指向已插入的节点末尾(一直是原区间的最左边节点, cur.Next则不断往后移动).


0003. 无重复字符的最长子串

	暴力法: 开头位置单个字符单调递增, 结束位置2重循环, 遇到重复字符就停止.

	滑动窗口: 

## 7月30日

0142. Linked List Cycle II
    用hash map记录访问过的节点即可, go的map可以存储指针: `make(map[*ListNode]struct{})`

## 7月31日

0143. Reorder List

```
我觉得可以把链表先装到slice里, 这样就可以通过index定位到结尾node以及任意的节点, 然后就可以按照要求重连linkedlist
```
    
## 8月1日

0128.  Longest Consecutive Sequence
    
```
    需要在O(n)时间内解决, 因此不能用排序O(nlogn).
    有一种方法是, 对数组中的某个num, 看num+1, num+2, ... ,num+y是否存在, 找到最大的那个y. 则以num开头的连续序列长度就是y+1.
    对每个数字, 都做这样的判断即可. 外层每个数字都做判断, O(n)复杂度; 内层如果用hash表, 每次判断O(1), 但y个数字, 也是O(n). 因此时间复杂度是O(n^2)
    但内层循环可以剪枝, 比如num如果寻找过, 则num+1,num+2就不需要寻找, 因为以num+1为首元素的序列肯定比num为首元素的序列短. 
    可以在内层循环是看hash表中num-1是否存在, 如果存在则跳过num首元素序列. 
    这样内层只有当num是连续序列的最小数时, 才会进入内循环, 于是内循环中每个数字只会进入1次. 因此总负责度是O(n)
```

## 8月2日

11. ntainer With Most Water

```
    头尾2个指针, 哪个矮哪个先向中间靠拢. 找到面积最大的那个.
    每次计算面积有些技巧: 比如每次移动一下就计算一下当前面积, 则代码很简洁.
    此外还有一种优化是移动后高度变小则不计算面积, 而是继续移动, 代码会复杂一些.
```

08. **String to Integer (atoi)**

```
    这是一道非常好的状态机题目, 将状态画出后, 构造出一个table, 然后就可以逐步tranfer状态, 值得反复回味.
    此外还考察了byte和int的转化 `int(c-'0')`, 以及int的溢出等问题
```

## 8月4日

75. Sort Colors

```
    关注循环不变量: 不断变量, 把下一个数放到合适的位置, 移动指针, 保持循环不变量
    解法2中, p0-1, p1-1分别是0和1的末尾
    解法3中, p0-1是0的末尾, p2+1是2开头
```

147. Insertion Sort List

```

```

2681. Power of Heroes